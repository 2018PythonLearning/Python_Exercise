### 3. 无重复字符的最长子串 O(N^2), c++, 32 ms, 65.17%
* 使用deque存储录入的字符，遇到重复的字符，删除前一个重复的字符之前的字符（包括重复的字符），记录其长度，和max进行比较
### 5. 最长回文子串 O(N^2), c++, 1076 ms, 6.04%
* 字符的两边如果相同的话，就放入str中，count+=2
* 每次和max进行比较
### 6. Z字形变换 O(N), c++, 28 ms, 93.45%
* 找规律，直接算
### 10.正则表达式匹配 O(N^N), c++, 280 ms, 10.70%  （有更简便方法）
* 使用递归
### 12. 整数转罗马数字O(N), c++, 112 ms, 3.53%
### 13. 罗马数字转整数O(N), c++, 80 ms, 84.84%
### 14. 最长公共前缀O(N^M), c++, 8 ms, 74.22%
* 将每个字符串的第i个字符进行对比，若相等将字符加入str，若不相等返回str
### 15. 电话号码的字母组合 O(3^N), c++, 0 ms, 100%
* 使用递归，将每个可能遍历过来
### 22. 括号生成 O(2^N), c++, 0 ms, 100%
* 使用递归
### 28. 实现strStr() O(N+M), c++, 4 ms, 99.39%
### 30. 与所有单词相关联的字串
> 显示超时
* 使用递归，传递了还未匹配过的参数和已经匹配过后的位置
### 32. 最长有效括号 O(N), c++, 12 ms, 56.52%
* 使用栈
* 遇到左括号入栈
* 遇到右括号判断栈顶是否为左括号或者数字，为数字则出栈，判断栈顶是否是左括号，不是左括号将数字再度入栈，是左括号，出栈，将数字+2入栈
* 最后选择栈中最大的值
### 38. 报数 O(N), c++, 4 ms, 73.81%
* 一个循环计数，一个循环用来判断下一个该输出什么字符串
### 43. 字符串相乘 O(N*M), c++, 8 ms, 98.88%
* 使用数组存储每位计算的出来的值，大于10则进位
### 44. 通配符匹配
> 显示超时
> 和30很像
### 49. 字母异位词分组 O(N), c++, 48 ms, 32.91%
* 先将字符串按字典排序
* 放入map
* 从map读取
### 58. 最后一个单词的长度 O(N), c++, 4 ms, 98.74%
### 65. 有效数字 O(N), c++, 8 ms, 32.50%
### 67. 二进制求和 O(N), c++, 4 ms, 94.33%
* 声明一个j用来存储是否进位
### 68. 文本左右对齐 O(N), c++, 4 ms, 22.50%
* 使用length来存储字符串的长度
* 当length将要大于maxWidth时，将字符串按照格式加入vs，length清零
* 最后一部分字符串单独进行处理
### 72. 编辑距离 O(NM), c++, 12 ms, 43.10%
* 使用动态规划
* 建立一个n*m大小的数组用来记录修改步骤
* 有三个修改方式，添加，删除和替换，从中选取最小的放入n*m大小的数组中

* 查看了网上的解答https://www.jianshu.com/p/7aa3698096a1
### 76. 最小覆盖子串 O(N+m), c++, 116 ms, 0%
* 定义个指针l指向字符串开头
* 建立两个数组，一个用来记录t中的字符出现个数
* 一个用来记录s中字符出现的个数
* 当t中字符都出现过的时候，将l移动到刚好无法符合t的位置，并记录下来，和上次记录进行判断，留下最小的

* 查看了网上的解答https://blog.csdn.net/suv1234/article/details/72829773
### 87. 扰乱字符串
> 好像和二叉树有关
### 91. 解码方法
> 想不出怎么用动态规划来解
### 93. 复原IP地址 O(N^3), c++, 8 ms, 9.41%
* 使用递归
* 结束条件为剩余最后一个空格，并且所剩下的字符小于256
### 97. 交错字符串 O(NM), c++, 0 ms, 100%
* 使用动态规划
* 建立一个N+1*M+1大的数组用来存储前面的字符串是否符合条件
* 如果前面的字符串符合条件，并且当前字符也符合条件，将当前位置设置成1

* 查看了网上的解答https://blog.csdn.net/lv1224/article/details/79906107
### 115. 不同的子序列 O(NM), c++, 8 ms, 33.93%
* 使用动态规划
* 建立一个N+1*M+1大的数组用来存储前面的字符串符合条件有几种方法
* 如果当前字符不相等，就获得前一个方法的数量，如果相等，就加上左上角方法的数量

* 查看了网上的解答https://blog.csdn.net/xiaocong1990/article/details/79625590
> 不知道为什么得出这个规律，现在全靠表格画出来才找到的规律
### 125. 验证回文串O(N), c++, 8 ms, 98.15%
* 只获取字符串中的字母和数字，并将所有的字母转换成小写，然后进行对比
### 126. 单词接龙 II
* 递归
> 超时
### 151. 翻转字符串里的单词O(N), c++, 8 ms, 45.57%
* 遇到空格添加，如果最后没有空格，就再添加一次