### 15. 三数之和O(N), c++, 124 ms, 34.08%
* 先排序
* 判断a小于或等于0时的情况
* b开始位置为a+1
* c开始位置为size-1
* 如果数字小了b++
* 如果数字大了c--
### 16. 最接近的三数之和 O(N), c++, 8 ms, 95.35%
* 先排序
* a开始位置i+1
* b开始位置size-1
* 将两个值相减，选择绝对值较小的那个
* 如果数字小了b++
* 如果数字大了c--
### 18. 四数之和 O(N^2), c++, 32 ms, 57.08%
* 先排序
* 判断相加后小于或等于target时的情况
* 使用两个循环来遍历前两个数
* b开始位置为a+1
* c开始位置为size-1
* 如果数字小了b++
* 如果数字大了c--
### 26. 删除排序数组中的重复项 O(N), c++, 28 ms, 74.25%
* 使用两个指针来记录遍历进度
* 如果相同i指针++，n不变
* 如果不相同n++，并将i的值赋给n，i++
### 27. 移除元素 O(N), c++, 4 ms, 100%
* 使用两个指针来记录遍历进度
* 如果不为val，i指针++
* 如果为val，将i的值赋给n，n++，i++
### 31. 下一个排列 O(N), c++, 12 ms, 95.38%
* 从最后一个数字进行遍历
* 如果遇到比前一个数字小的数字，将它存储起来
* 再次遍历数组，遇到比存储起来的数字大的就将两个数字互换
* 最后排序交换数字之后的数组
### 33. 搜索旋转排序数组 O(log N), c++, 4 ms, 99.75%
* 二分查找法
* 如果最右侧比中间大，那么右侧有序
* 如果最右侧比中间小，那么左侧有序
### 35. 搜索插入位置 O(log N), c++, 4 ms, 99.72%
* 二分查找法
* 如果没有查找到位置，那么判断如果比nums[r]大，返回r+1，否则返回r
### 39. 组合总和 O(N^2), c++, 16 ms, 57.31%
* 递归
* 全部匹配完，退出递归
* 当相加后的值大于target退出递归
* 当值相等后将数组压入vector，退出递归
* 正常for循环将之后的数字都添加进数组一次
### 40. 组合总和 II O(N^2), c++, 16 ms, 43.69%
* 和上一题一样
* 区别在于先排序，然后在判断里面遇到和前一个相同并且不是第一个的跳过
### 41. 缺失的第一个正数 O(N), c++, 4 ms, 99.04%
* 遍历一遍数组，将数组中的各个数放到合适的地方比如：1放到0,2放到1，遇到大于数组或者小于1或者重复的数字时，跳过
### 45. 跳跃游戏 II O(N), c++, 12 ms, 90.29%
* 每次寻找一步之中可以跨的最远的步子··