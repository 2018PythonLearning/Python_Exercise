### 15. 三数之和O(N), c++, 124 ms, 34.08%
* 先排序
* 判断a小于或等于0时的情况
* b开始位置为a+1
* c开始位置为size-1
* 如果数字小了b++
* 如果数字大了c--
### 16. 最接近的三数之和 O(N), c++, 8 ms, 95.35%
* 先排序
* a开始位置i+1
* b开始位置size-1
* 将两个值相减，选择绝对值较小的那个
* 如果数字小了b++
* 如果数字大了c--
### 18. 四数之和 O(N^2), c++, 32 ms, 57.08%
* 先排序
* 判断相加后小于或等于target时的情况
* 使用两个循环来遍历前两个数
* b开始位置为a+1
* c开始位置为size-1
* 如果数字小了b++
* 如果数字大了c--
### 26. 删除排序数组中的重复项 O(N), c++, 28 ms, 74.25%
* 使用两个指针来记录遍历进度
* 如果相同i指针++，n不变
* 如果不相同n++，并将i的值赋给n，i++
### 27. 移除元素 O(N), c++, 4 ms, 100%
* 使用两个指针来记录遍历进度
* 如果不为val，i指针++
* 如果为val，将i的值赋给n，n++，i++
### 31. 下一个排列 O(N), c++, 12 ms, 95.38%
* 从最后一个数字进行遍历
* 如果遇到比前一个数字小的数字，将它存储起来
* 再次遍历数组，遇到比存储起来的数字大的就将两个数字互换
* 最后排序交换数字之后的数组
### 33. 搜索旋转排序数组 O(log N), c++, 4 ms, 99.75%
* 二分查找法
* 如果最右侧比中间大，那么右侧有序
* 如果最右侧比中间小，那么左侧有序
### 35. 搜索插入位置 O(log N), c++, 4 ms, 99.72%
* 二分查找法
* 如果没有查找到位置，那么判断如果比nums[r]大，返回r+1，否则返回r
### 39. 组合总和 O(N^2), c++, 16 ms, 57.31%
* 递归
* 全部匹配完，退出递归
* 当相加后的值大于target退出递归
* 当值相等后将数组压入vector，退出递归
* 正常for循环将之后的数字都添加进数组一次
### 40. 组合总和 II O(N^2), c++, 16 ms, 43.69%
* 和上一题一样
* 区别在于先排序，然后在判断里面遇到和前一个相同并且不是第一个的跳过
### 41. 缺失的第一个正数 O(N), c++, 4 ms, 99.04%
* 遍历一遍数组，将数组中的各个数放到合适的地方比如：1放到0,2放到1，遇到大于数组或者小于1或者重复的数字时，跳过
### 45. 跳跃游戏 II O(N), c++, 12 ms, 90.29%
* 每次寻找一步之中可以跨的最远的步子
### 48. 旋转图像 O(N^2), c++, 4 ms, 90.94%
* 将第一条边依次和剩余三条边进行交换，依次循环至最中心
* 将右上角到左下角的值交换一下，如xy和yx的值交换
### 53. 最大子序和 O(N), c++, 8 ms, 97.44%
* 声明两个值，一个用来记录当前值
* 一个从来记录最大值
* 如果遇到的数字大于当前值，那么就直接重置当前值
### 54. 螺旋矩阵 O(mn), c++, 0 ms, 100%
* 定义四个方向，每个方向设一个结束的值，当遇到结束的值的时候转向，并改变结束值，直到全部遍历一遍
### 55. 跳跃游戏 O(N), c++, 8 ms, 98%
* 每次寻找一步之中可以跨的最远的步子,如果遇到最大步子为0的话就无法通过
### 56. 合并区间 O(N), c++, 12 ms, 96.53%
* 先按照start排序
* 遇到start小于前面的end的，将两个intervals合并
### 57. 插入区间 O(N), c++, 12 ms, 98.02%
* 先将newInterval插入
* 然后进行上一题的步骤
### 59. 螺旋矩阵 II O(N*N), c++, 4 ms, 99.74%
* 先创建一个n*n的矩阵
* 然后使用54题的方法一个个赋值
### 62. 不同路径 O(N*M), c++, 0 ms, 100%
* 使用动态规划
* 将第一行和第一列设为1
* 每一格为上一行同列与上一列同行的和
### 63. 不同路径 II O(N*M), c++, 4 ms, 88.74%
* 如果终点或起点为障碍物时，答案为0
* 使用动态规划
* 将障碍物设置为-1
* 将第一行和第一列至障碍物的部分赋值为z
* 每一格为上一行同列与上一列同行的和
* 特殊情况
	* 当左和上都为-1时，当前值为0
	* 当前值为-1时，不作为
	* 上为-1时，当前值为左
	* 左为-1时，当前值为上
### 64. 最小路径和 O(N*M), c++, 8 ms, 97.81%
* 使用动态规划
* 每格的选择左或上小的那个数相加
### 66. 加一 O(N), c++, 0 ms, 100%
* 如果全是9，那么返回数组1后面跟原来数量的0
* 否则遇到9就更改为0，并进位，直到遇到非9的数字，加1
### 73. 矩阵置零 O(N*M), c++, 44 ms, 99.66%
* 使用两个变量来记录第一行和第一列是否有0
* 然后使用第一行和第一列来记录哪些需要置零
* 最后根据两个变量来判断是否置零第一行第一列
### 74. 搜索二维矩阵 O(logm + logn), c++, 8 ms, 97.46%
* 先用二分查找法找到所在行
* 再用二分查找法找到所在位置
### 75. 颜色分类 O(N), c++, 4 ms, 96.48%
* 使用两个指针指向左和右，右指针指向第一个非2值
* 开始遍历遇到0和左指针交换，左++
* 遇到1，跳过
* 遇到2，和右指针交换并将右指针指向第一个非2值
### 78. 子集 O(N^N), c++, 4 ms, 100%
* 使用递归
* 三个参数
	* 一个用来传原始字符串
	* 一个用来传已经遍历到第几位
	* 一个用来传已经添加的字符串
* 当遍历到结束时，添加新的字符串
### 79. 单词搜索 O(N^2), c++, 56 ms, 33.72%
> 时间复杂度不确定

* 从数组中每一个合适的开头出发
* 进行递归，没经过一个将当前位置置零，直到经过数量等于单词长度
### 80. 删除排序数组中的重复项 II O(N), c++, 12 ms, 99.85%
* 使用三个参数
	* 第一个记录重复次数
	* 第二个记录重复的数字
	* 第三个记录更改后最后一个的位置
* 遇到和重复相同的数字时，计次++
* 遇到不同时，在第三个参数的位置加入计次个的重复数字（最大为2），并且把次数重置为1，将重复数字更改为当前数字
* 退出循环后，再次在第三个参数位置处加入计次个的重复数字（最大为2）
### 81. 搜索旋转排序数组 II O(log N), c++, 4 ms, 99.28%
* 二分查找法
* 先将最右侧相同的相邻的全部去掉
* 如果最右侧比中间大，那么右侧有序
* 如果最右侧比中间小，那么左侧有序
### 88. 合并两个有序数组 O(N+M), c++, 4 ms, 100%
* 先将nums1中的有效数据转移到尾部
* 一个个和nums2中的数据比较，小的先放入
* 最后将没放完的数据放入
### 90. 子集 II O(N^N), c++, 8 ms, 99.56%
* 使用递归
* 三个参数
	* 一个用来传原始字符串
	* 一个用来传已经遍历到第几位
	* 一个用来传已经添加的字符串
* 在每次遍历时，如果将要添加的和上一个一样，就跳过
* 当遍历到结束时，添加新的字符串
### 118. 杨辉三角 O(N*M), c++, 0 ms, 100%
* 先定义上面三个值
* 之后在两边加1，中间的由上面两个相加得出

> 时间复杂度 不确定
### 119. 杨辉三角 II O(N*M), c++, 0 ms, 100%
* 和上一题一样，只是只用保存一行的值
### 120. 三角形最小路径和 O(N*M), c++, 4 ms, 100%
* 使用动态规划
* 使用一行数组来存储每一行的更新程度
* 最后遍历更新完的数组，选择其中最小的那个
### 121. 买卖股票的最佳时机 O(N), c++, 4 ms, 100%
* 使用两个值，一个值用来存储买入的最低价格，一个值用来存储卖出的最高价格
### 123. 买卖股票的最佳时机 III O(N), c++, 8 ms, 79.74%
* 使用两个数组分别存储从左往右和从右往左的最大利润
* 最后，将两个数组中的同一个结点结束的最大值返回