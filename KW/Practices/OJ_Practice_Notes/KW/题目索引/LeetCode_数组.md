### 15. 三数之和O(N), c++, 124 ms, 34.08%
* 先排序
* 判断a小于或等于0时的情况
* b开始位置为a+1
* c开始位置为size-1
* 如果数字小了b++
* 如果数字大了c--
### 16. 最接近的三数之和 O(N), c++, 8 ms, 95.35%
* 先排序
* a开始位置i+1
* b开始位置size-1
* 将两个值相减，选择绝对值较小的那个
* 如果数字小了b++
* 如果数字大了c--
### 18. 四数之和 O(N^2), c++, 32 ms, 57.08%
* 先排序
* 判断相加后小于或等于target时的情况
* 使用两个循环来遍历前两个数
* b开始位置为a+1
* c开始位置为size-1
* 如果数字小了b++
* 如果数字大了c--
### 26. 删除排序数组中的重复项 O(N), c++, 28 ms, 74.25%
* 使用两个指针来记录遍历进度
* 如果相同i指针++，n不变
* 如果不相同n++，并将i的值赋给n，i++
### 27. 移除元素 O(N), c++, 4 ms, 100%
* 使用两个指针来记录遍历进度
* 如果不为val，i指针++
* 如果为val，将i的值赋给n，n++，i++
### 31. 下一个排列 O(N), c++, 12 ms, 95.38%
* 从最后一个数字进行遍历
* 如果遇到比前一个数字小的数字，将它存储起来
* 再次遍历数组，遇到比存储起来的数字大的就将两个数字互换
* 最后排序交换数字之后的数组
### 33. 搜索旋转排序数组 O(log N), c++, 4 ms, 99.75%
* 二分查找法
* 如果最右侧比中间大，那么右侧有序
* 如果最右侧比中间小，那么左侧有序
### 35. 搜索插入位置 O(log N), c++, 4 ms, 99.72%
* 二分查找法
* 如果没有查找到位置，那么判断如果比nums[r]大，返回r+1，否则返回r
### 39. 组合总和 O(N^2), c++, 16 ms, 57.31%
* 递归
* 全部匹配完，退出递归
* 当相加后的值大于target退出递归
* 当值相等后将数组压入vector，退出递归
* 正常for循环将之后的数字都添加进数组一次
### 40. 组合总和 II O(N^2), c++, 16 ms, 43.69%
* 和上一题一样
* 区别在于先排序，然后在判断里面遇到和前一个相同并且不是第一个的跳过
### 41. 缺失的第一个正数 O(N), c++, 4 ms, 99.04%
* 遍历一遍数组，将数组中的各个数放到合适的地方比如：1放到0,2放到1，遇到大于数组或者小于1或者重复的数字时，跳过
### 45. 跳跃游戏 II O(N), c++, 12 ms, 90.29%
* 每次寻找一步之中可以跨的最远的步子
### 48. 旋转图像 O(N^2), c++, 4 ms, 90.94%
* 将第一条边依次和剩余三条边进行交换，依次循环至最中心
* 将右上角到左下角的值交换一下，如xy和yx的值交换
### 53. 最大子序和 O(N), c++, 8 ms, 97.44%
* 声明两个值，一个用来记录当前值
* 一个从来记录最大值
* 如果遇到的数字大于当前值，那么就直接重置当前值
### 54. 螺旋矩阵 O(mn), c++, 0 ms, 100%
* 定义四个方向，每个方向设一个结束的值，当遇到结束的值的时候转向，并改变结束值，直到全部遍历一遍
### 55. 跳跃游戏 O(N), c++, 8 ms, 98%
* 每次寻找一步之中可以跨的最远的步子,如果遇到最大步子为0的话就无法通过
### 56. 合并区间 O(N), c++, 12 ms, 96.53%
* 先按照start排序
* 遇到start小于前面的end的，将两个intervals合并
### 57. 插入区间 O(N), c++, 12 ms, 98.02%
* 先将newInterval插入
* 然后进行上一题的步骤