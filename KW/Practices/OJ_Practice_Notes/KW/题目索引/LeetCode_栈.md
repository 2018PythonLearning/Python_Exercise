### 20.有效的括号
### 42.接雨水
* 将一个个数字入栈，当遇到比栈中第一个数字大的时候，将清空栈，将第一个数字乘以栈中的数的量-1，再减去栈中的数字除第一个外的数，最后将栈中的值反过来再操作一遍
### 71.简化路径
* 将path以‘/’分隔成一串串字符串，然后遇到..从栈中删除，遇到除‘.’和‘..’之外的字符串入栈，最后转换成string类型的字符串
### 84.柱状图中最大的矩形
* 使用栈将数组变成升序，每次遇到小的数就计算那一块的最大矩形
### 85.最大矩形
* 一排排的运行上题的函数
### 94.二叉树的中序遍历
> 二叉树
### 103.二叉树的锯齿形层次遍历
> 二叉树
### 144.二叉树的前序遍历
> 二叉树
### 145.二叉树的后序遍历
> 二叉树
### 150.逆波兰式表达式求值
* 遇到数字转换成int类型，遇到运算符将栈中两个数字进行运算
### 155.最小栈
* 在pop和push的时候计算min
### 173.二叉树搜索树迭代器
> 二叉树
### 224.基本计算器
* 使用两个栈，一个存储数字，一个存储运算符，遇到运算符进行运算，遇到数字存储
### 225.用队列实现栈
* 使用两个队列来模拟。
### 232.用栈实现队列
* 使用两个栈来模拟。
### 316.去除重复字母 O(N), c++, 4 ms, 100%
* 遍历一遍求出所有字符数目
* 再遍历一遍 入栈出栈 更新剩余数目数组即可，并判断栈中是否已存在当前字符，如果已经存在，就跳过
### 331.验证二叉树的前序序列化
> 二叉树
### 341.扁平化嵌套列表迭代器  *
* 在初始化时全部入栈
* 在next里返回栈中第一个元素并出栈
* 在hasNext中将栈中第一个元素拆开，然后入栈，直到第一个元素为int时返回true，若栈中无元素返回false
### 385.Mini Parser *
* 遇到【时将空的NestInteger入栈。
* 遇到，或】时，如果前一个是数字，那么给栈顶元素调用add来新加一个NestInteger。
* 遇到】时，如果栈中元素大于1，那么取出，使用add函数加入新的栈顶元素。
### 394.字符串解码
* 遇到数字、字母和 [ 存储，遇到 ] 将 [ 之后所有的字母组合成字符串，并且重复之前的数字次。
### 402.移掉K位数字
* 从前k个字符里面找到最小的成为第一个数字，后来每次搜索范围为新的数+1到所有数-以获取数。
### 456.132模式
* 有思路，实现起来总是错的，查看了网上解答：https://www.cnblogs.com/grandyang/p/6081984.html
### 496.下一个更大元素1
> 没有使用栈

* 两个循环
### 503.下一个更大元素2
> 没有使用栈

* 两个循环
### 591.标签验证器
* 判断开头是否是标签
* 遇到标签头入栈，遇到标签尾出栈
* 遇到<![CDATA[就入栈，直到]]>出栈，不判断cdata里面的字符串

### 636.函数的独占时间
* 直接计算，基本没用栈
* 第二种使用了vector
> 没用栈
### 682.棒球比赛
* 遇整数入栈，遇+计算后入栈，遇d计算后入栈，遇c出栈一个

### 726.原子的数量
* 定义一个结构，存储原子名和数量
* 遇到大写字母push，并将之后的小写字母也一起push，原子数量为1
* 遇到数字，将之前结构中的数量乘2
* 遇到左括号push
* 遇到右括号，将之前直到左括号的数量全部乘以括号后的数
* 排序
* 将同名的原子名数量相加，依次放入string中
### 735.行星碰撞
* 遇到正数入栈
* 遇到负数判断前面一个是不是正数，有，取决对值比较，大的留下，小的删除，相等都删除
### 739.每日温度 * O(n), c++, 236 ms, 61.11%
* 使用栈来存储一个递减的序列，遇到大的出栈算距离
### 770.Basic Calculator IV
> 不会